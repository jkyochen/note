# interface

接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部特征。

对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征（即全部的方法），那么它就一定是这个接口的实现类型。

## 怎样判定一个数据类型的某一个方法实现的就是某个接口类型中的某个方法呢？

1. 两个方法的签名需要完全一致
2. 两个方法的名称要一模一样

```golang
type Pet interface {
    SetName(name string)
    Name() string
    Category() string
}

dog := Dog{"little pig"}
var pet Pet = &dog
```

对于一个接口类型的变量来说，例如上面的变量 pet，我们赋给它的值可以被叫做它的实际值（也称动态值），而该值的类型可以被叫做这个变量的实际类型（也称动态类型）。

对于变量 pet 来讲，它的静态类型就是 Pet，并且永远是 Pet，但是它的动态类型却会随着我们赋给它的动态值而变化。

在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的。

## 当我们为一个接口变量赋值时会发生什么？

如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本。

接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是 nil，这也是它的零值。


当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中。这样一个变量的值其实是这个专用数据结构的一个实例，而不是我们赋给该变量的那个实际的值。

我们就把这个专用的数据结构叫做 iface 吧，在 Go 语言的 runtime 包中它其实就叫这个名字。iface 的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。

接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。

## 问题 1：接口变量的值在什么情况下才真正为 nil？

在 Go 语言中，我们把由字面量 nil 表示的值叫做无类型的 nil。这是真正的 nil，因为它的类型也是 nil 的。

Go 语言会识别出赋予 pet 的值是一个 `*Dog` 类型的 nil。然后，Go 语言就会用一个 iface 的实例包装它，包装后的产物肯定就不是 nil 了。

那么，怎样才能让一个接口变量的值真正为 nil 呢？要么只声明它但不做初始化，要么直接把字面量 nil 赋给它。


## 问题 2：怎样实现接口之间的组合？

```golang
type Aniaml interface {
    SicentificName() string
    Category() string
}

type Pet interface {
    Aniaml
    Name() string
}
```

接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。


Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。

这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起。

Go 语言标准库代码包 io 中的 ReadWriteCloser 接口和 ReadWriter 接口就是这样的例子，它们都是由若干个小接口组合而成的。以 io.ReadWriteCloser 接口为例，它是由 io.Reader、io.Writer 和 io.Closer 这三个接口组成的。

即使我们只实现了 io.Reader 和 io.Writer，那么也等同于实现了 io.ReadWriter 接口，因为后者就是前两个接口组成的。可以看到，这几个 io 包中的接口共同组成了一个接口矩阵。它们既相互关联又独立存在。
