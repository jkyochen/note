# interface

接口定义了方法的集合，这些方法依托于运行时的接口对象，因此接口对应的方法是在运行时动态绑定的。Go 语言通过隐式接口机制实现了鸭子面向对象模型。

Go 语言中的面向对象就是如此，如果一个对象只要看起来像是某种接口类型的实现，那么它就可以作为该接口类型使用。这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不用去破坏这些类型原有的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其灵活有用。Go 语言的接口类型是延迟绑定，可以实现类似虚函数的多态功能。

fmt.Printf 函数的设计就是完全基于接口的，它的真正功能由 fmt.Fprintf 函数完成。用于表示错误的 error 类型更是内置的接口类型。

任意隐式满足 fmt.Stringer 接口的对象都可以打印，不满足 fmt.Stringer 接口的依然可以通过反射的技术打印。

Go 语言中，对于基础类型（非接口类型）不支持隐式的转换，我们无法将一个 int 类型的值直接赋值给 int64 类型的变量，也无法将 int 类型的值赋值给底层是 int 类型的新定义命名类型的变量。

Go 语言对基础类型的类型一致性要求可谓是非常的严格，但是 Go 语言对于接口类型的转换则非常的灵活。对象和接口之间的转换、接口和接口之间的转换都可能是隐式的转换。

```golang
var (
    a io.ReadCloser = (*os.File)(f) // 隐式转换, *os.File 满足 io.ReadCloser 接口
    b io.Reader     = a             // 隐式转换, io.ReadCloser 满足 io.Reader 接口
    c io.Closer     = a             // 隐式转换, io.ReadCloser 满足 io.Closer 接口
    d io.Reader     = c.(io.Reader) // 显式转换, io.Closer 不满足 io.Reader 接口
)
```

## 限制适配

有时候对象和接口之间太灵活了，导致我们需要人为地限制这种无意之间的适配。常见的做法是定义一个含特殊方法来区分接口。比如 runtime 包中的 Error 接口就定义了一个特有的 RuntimeError 方法，用于避免其它类型无意中适配了该接口。

再严格一点的做法是给接口定义一个私有方法。只有满足了这个私有方法的对象才可能满足这个接口，而私有方法的名字是包含包的绝对路径名的，因此只能在包内部实现这个私有方法才能满足这个接口。测试包中的 testing.TB 接口就是采用类似的技术。

不过这种通过私有方法禁止外部对象实现接口的做法也是有代价的：首先是这个接口只能包内部使用，外部包正常情况下是无法直接创建满足该接口对象的；其次，这种防护措施也不是绝对的，恶意的用户依然可以绕过这种保护机制。

通过在结构体中嵌入匿名类型成员，可以继承匿名类型的方法。其实这个被嵌入的匿名成员不一定是普通类型，也可以是接口类型。我们可以通过嵌入匿名的 testing.TB 接口来伪造私有的 private 方法，因为接口方法是延迟绑定，编译时 private 方法是否真的存在并不重要。

通过嵌入匿名接口或嵌入匿名指针对象来实现继承的做法其实是一种纯虚继承，我们继承的只是接口指定的规范，真正的实现在运行的时候才被注入。

## 怎样判定一个数据类型的某一个方法实现的就是某个接口类型中的某个方法呢？

1. 两个方法的签名需要完全一致
2. 两个方法的名称要一模一样

```golang
type Pet interface {
    SetName(name string)
    Name() string
    Category() string
}

dog := Dog{"little pig"}
var pet Pet = &dog
```

对于一个接口类型的变量来说，例如上面的变量 pet，我们赋给它的值可以被叫做它的实际值（也称动态值），而该值的类型可以被叫做这个变量的实际类型（也称动态类型）。

对于变量 pet 来讲，它的静态类型就是 Pet，并且永远是 Pet，但是它的动态类型却会随着我们赋给它的动态值而变化。

在我们给一个接口类型的变量赋予实际的值之前，它的动态类型是不存在的。

## 当我们为一个接口变量赋值时会发生什么？

如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本。

接口类型本身是无法被值化的。在我们赋予它实际的值之前，它的值一定会是 nil，这也是它的零值。

当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构中。这样一个变量的值其实是这个专用数据结构的一个实例，而不是我们赋给该变量的那个实际的值。

我们就把这个专用的数据结构叫做 iface 吧，在 Go 语言的 runtime 包中它其实就叫这个名字。iface 的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。

接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。

## 问题 1：接口变量的值在什么情况下才真正为 nil？

在 Go 语言中，我们把由字面量 nil 表示的值叫做无类型的 nil。这是真正的 nil，因为它的类型也是 nil 的。

Go 语言会识别出赋予 pet 的值是一个 `*Dog` 类型的 nil。然后，Go 语言就会用一个 iface 的实例包装它，包装后的产物肯定就不是 nil 了。

那么，怎样才能让一个接口变量的值真正为 nil 呢？要么只声明它但不做初始化，要么直接把字面量 nil 赋给它。

## 问题 2：怎样实现接口之间的组合？

```golang
type Aniaml interface {
    SicentificName() string
    Category() string
}

type Pet interface {
    Aniaml
    Name() string
}
```

接口类型间的嵌入要更简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。

Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。

这是因为相比于包含很多方法的大接口而言，小接口可以更加专注地表达某一种能力或某一类特征，同时也更容易被组合在一起。

Go 语言标准库代码包 io 中的 ReadWriteCloser 接口和 ReadWriter 接口就是这样的例子，它们都是由若干个小接口组合而成的。以 io.ReadWriteCloser 接口为例，它是由 io.Reader、io.Writer 和 io.Closer 这三个接口组成的。

即使我们只实现了 io.Reader 和 io.Writer，那么也等同于实现了 io.ReadWriter 接口，因为后者就是前两个接口组成的。可以看到，这几个 io 包中的接口共同组成了一个接口矩阵。它们既相互关联又独立存在。
