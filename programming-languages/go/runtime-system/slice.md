# Slice

**引用类型**

## 数组和切片的异同点

数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。

### 共同点

都属于集合类的类型，并且，它们的值也都可以用来存储某一种类型的值（或者说元素）。

### 不同点

1. 数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。

2. 数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，数组的长度是其类型的一部分。比如， `[1]string` 和 `[2]string` 就是两个不同的数组类型。而切片的类型字面量中只有元素的类型，而没有长度。切片的长度可以自动地随着其中元素数量的增长而增长，但不会随着元素数量的减少而减小。

3. Go 语言的切片类型属于引用类型，同属引用类型的还有字典类型、通道类型、函数类型等；而 Go 语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型。



如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。

在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们之上也都可以应用切片表达式，也都会得到一个新的切片。

通过调用内建函数 len，得到数组和切片的长度。通过调用内建函数 cap，我们可以得到它们的容量。但要注意，数组的容量永远等于其长度，都是不可变的。切片的容量却不是这样，并且它的变化是有规律可寻的。


```golang
s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
s4 := s3[3:6] // 左开右闭
fmt.Printf("The length fo s4: %d \n", len(s4))
fmt.Printf("The capacity fo s4: %d \n", cap(s4))
fmt.Printf("The value fo s4: %d \n", s4)
```

**有一个窗口，你可以通过这个窗口看到一个数组，但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素，一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。**

切片的容量代表了它的底层数组的长度，但这仅限于使用 make 函数或者切片值字面量初始化切片的情况。

`s4[0:cap(s4)]`


## 切片容量的增长

扩容会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。

在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。

当原切片的长度（以下简称原长度）大于或等于 1024 时，Go 语言将会以原容量的 1.25 倍作为新容量的基准（以下新容量基准）。

如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准。

更多细节可参见 runtime 包中 slice.go 文件里的 growslice 及相关函数的具体实现。


## 切片的底层数组什么时候会被替换？

它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。

在无需扩容时，append 函数返回的是指向原底层数组的新切片，而在需要扩容时，append 函数返回的是指向新底层数组的新切片。只要新长度不会超过切片的原容量，那么使用 append 函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。

append 函数总会返回新的切片，而且如果新切片的容量比原切片的容量更大那么就意味着底层数组也是新的了。
