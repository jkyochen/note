# map

**引用类型**

```golang
aMap := map[string]int{
    "one":   1,
    "two":   2,
    "three": 3,
}

k := "two"
v, ok := aMap[k]
if ok {
    fmt.Printf("The element of key %q: %d\n", k, v)
} else {
    fmt.Printf("Not Found!")
}
```

Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。

## 映射

哈希表会先用哈希函数（hash function）把键值转换为哈希值。哈希值通常是一个无符号的整数。一个哈希表会持有一定数量的桶（bucket），我们也可以叫它哈希桶，这些哈希桶会均匀地储存其所属哈希表收纳的键 - 元素对。

因此，哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。

## 字典的键类型不能是哪些类型？

Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。

Go 语言规范规定，在键类型的值之间必须可以施加操作符 == 和 !=。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。

另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。

```golang
var badMap2 = map[interface{}]int{
    "1":   1,
    []int{2}: 2, // 这里会引发 panic。
    3:    3,
}
```

还要注意，如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。


## 应该优先考虑哪些类型作为字典的键类型？

求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。宽度越小的类型速度通常越快。类型的宽度是指它的单个值需要占用的字节数。

以上说的都是基本类型，再来看高级类型。对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。细则同上。

与之类似，对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。而对于接口类型，具体的哈希算法，则由值的实际类型决定。


我不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。

优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。


## 在值为 nil 的字典上执行读操作会成功吗，那写操作呢？

除了添加键值元素对，我们在一个值为 nil 的字典上做任何操作都不会引起错误。当我们试图在一个值为 nil 的字典中添加键值元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。

非原子操作需要加锁， map 并发读写需要加锁，map 操作不是并发安全的，判断一个操作是否是原子的可以使用 go run race 命令做数据的竞争检测。
