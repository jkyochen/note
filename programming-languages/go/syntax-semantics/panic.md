# panic

panic支持抛出任意类型的异常（而不仅仅是error类型的错误），recover函数调用的返回值和panic函数的输入参数类型一致，它们的函数签名如下：

```golang
func panic(interface{})
func recover() interface{}
```

为了避免 recover 调用者不能识别捕获到的异常, 应该避免用 nil 为参数抛出异常。

Go 语言库的实现习惯: 即使在包内部使用了 panic，但是在导出函数时会被转化为明确的错误值。

```golang
func main() {
    defer func() {
        if r := recover(); r != nil {

        }
        // 虽然总是返回nil, 但是可以恢复异常状态
    }()
    panic(nil)
}
```

## 从 panic 被引发到程序终止运行的大致过程是什么？

1. 某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。

2. 它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。这里的最外层函数指的是 go 函数，对于主 goroutine 来说就是 main 函数。

3. 控制权也不会停留在那里，而是被 Go 语言运行时系统收回。

4. 随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。

## 怎样让 panic 包含一个值，以及应该让它包含什么样的值？

自己定义的 Error 方法或者 String 方法。因此，为不同的数据类型分别编写这两种方法总是首选。
