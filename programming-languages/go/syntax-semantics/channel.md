# channel

**引用类型**

Don’t communicate by sharing memory; share memory by communicating. （不要通过共享内存来通信，而应该通过通信来共享内存。）

一个通道相当于一个先进先出（FIFO）的队列。

通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符 `<-`。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。

```golang
ch1 := make(chan int, 3)
ch1 <- 2
ch1 <- 1
ch1 <- 3
elem1 := <-ch1
fmt.Printf("The first element received from channel cha: %v\n", elem1)
```

`<-ch1`，这也可以被叫做接收表达式。在一般情况下，接收表达式的结果将会是通道中的一个元素值。

从已关闭的通道中接收到的是其元素类型的零值。

## 对通道的发送和接收操作都有哪些基本的特性？

它们的基本特性如下。

1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
2. 发送操作和接收操作中对元素值的处理都是不可分割的。
3. 发送操作在完全完成之前会被阻塞。接收操作也是如此。

元素值从外界进入通道时会被复制。发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。

## 发送操作和接收操作在什么时候可能被长时间的阻塞？

### 缓冲通道（异步）

如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。

如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。

### 非缓冲通道（同步）

无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。

数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。

### 通道阻塞

对于值为 nil 的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。

## 发送操作和接收操作在什么时候会引发 panic？

+ 对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。
+ 试图关闭一个已经关闭了的通道，也会引发 panic。


把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定 bool 类型。它的值如果为 false 就说明通道已经关闭，并且再没有元素值可取了。

注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是 true。因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。
