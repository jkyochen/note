# panic recover defer

## 从 panic 被引发到程序终止运行的大致过程是什么？

1. 某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。

2. 它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。这里的最外层函数指的是 go 函数，对于主 goroutine 来说就是 main 函数。

3. 控制权也不会停留在那里，而是被 Go 语言运行时系统收回。

4. 随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。

## 问题 1：怎样让 panic 包含一个值，以及应该让它包含什么样的值？

自己定义的 Error 方法或者 String 方法。因此，为不同的数据类型分别编写这两种方法总是首选。

## 问题 2：怎样施加应对 panic 的保护措施，从而避免程序崩溃？

```golang
func main() {
    fmt.Println("Enter function main.")

    defer func() {
        fmt.Println("Enter defer function.")
        if p := recover(); p != nil {
            fmt.Printf("panic: %s\n", p)
        }
        fmt.Println("Exit defer function.")
    }()

    panic(errors.New("something wrong"))
    fmt.Println("Exit function main.")
}
```

### recover

内建函数 recover 专用于恢复 panic，或者说平息运行时恐慌。

recover 函数无需任何参数，并且会返回一个空接口类型的值，如果在调用它时并没有 panic 发生，那么这个结果值就会是nil。

如果被恢复的 panic 是我们通过调用 panic 函数引发的，那么它返回的结果值就会是我们传给 panic 函数参数值的副本。

### defer

defer 语句就是被用来延迟执行代码的。延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么。这里存在一些限制，有一些调用表达式是不能出现在这里的，包括：针对 Go 语言内建函数的调用表达式，以及针对 unsafe 包中的函数的调用表达式。对于 go 语句中的调用表达式，限制也是一样的。

在这里被调用的函数可以是有名称的，也可以是匿名的。我们可以把这里的函数叫做 defer 函数或者延迟函数。被延迟执行的是 defer 函数，而不是 defer 语句。

我们要尽量把 defer 语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会。

## 问题 3：如果一个函数中有多条 defer 语句，那么那几个 defer 函数调用的执行顺序是怎样的？

在同一个函数中，defer 函数调用的执行顺序与它们分别所属的 defer 语句的出现顺序（执行顺序）完全相反。

在 defer 语句每次执行的时候，Go 语言会把它携带的 defer 函数及其参数值另行存储到一个队列中。这个队列与该 defer 语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。在需要执行某个函数中的 defer 函数调用的时候，Go 语言会先拿到对应的队列，然后从该队列中一个一个地取出 defer 函数及其参数值，并逐个执行调用。
