# Type

## 判断变量类型

```golang
var container = []string{"zero", "one", "two"}

func main() {
    container := map[int]string{0: "zero", 1: "one", 2: "two"}

    value, ok := interface{}(container).([]string)

    fmt.Println("The element is %q.\n", container[1], value, ok)
}
```

这里的 ok 没有的话，当判断为否时就会引发 Panic。

类型断言表达式的语法形式是 `x.(T)`。其中的 x 代表要被判断类型的值。这个值当下的类型必须是接口类型的。

## 类型转换

类型转换表达式的基本写法，它的语法形式是 `T(x)`。

在这个上下文中，x 可以被叫做源值，它的类型就是源类型，而那个 T 代表的类型就是目标类型。

1. 首先，对于整数类型值、整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的。

    当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可。

    当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉。

2. 虽然直接把一个整数值转换为一个 string 类型的值是可行的，但值得关注的是，被转换的整数值应该可以代表一个有效的 Unicode 代码点，否则转换的结果将会是 "�"（仅由高亮的问号组成的字符串值）。`string(-1) // "�"`

3. string 类型与各种切片类型之间的互转的。

    一个值在从 string 类型向 []byte 类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节。除了与 ASCII 编码兼容的那部分字符集，以 UTF-8 编码的某个单一字节是无法代表一个字符的。

    `string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'})` // 你好

    其次，一个值在从 string 类型向 []rune 类型转换时代表着字符串会被拆分成一个个 Unicode 字符。

    `string([]rune{'\u4F60', '\u597D'})` // 你好

## 别名类型

可以用关键字 type 声明自定义的各种类型。当然了，这些类型必须在 Go 语言基本类型和高级类型的范畴之内。

`type MyString = string`

别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的。别名类型主要是为了代码重构而存在的。

Go 语言内建的基本类型中就存在两个别名类型。byte 是 uint8 的别名类型，而 rune 是 int32 的别名类型。

## 潜在类型

`type MyString2 string` // 注意，这里没有等号。

MyString2 和 string 就是两个不同的类型了。这里的 MyString2 是一个新的类型，不同于其他任何类型。这种方式也可以被叫做对类型的再定义。我们刚刚把 string 类型再定义成了另外一个类型 MyString2。

对于这里的类型再定义来说，string可以被称为MyString2的潜在类型。潜在类型的含义是，某个类型在本质上是哪个类型。


潜在类型相同的不同类型的值之间是可以进行类型转换的。

但对于集合类的类型 []MyString2 与 []string 来说这样做却是不合法的，因为 []MyString2 与 []string 的潜在类型不同，分别是 []MyString2 和 []string 。

另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。
