# test

测试源码文件的主名称应该以被测源码文件的主名称为前导，并且必须以 `_test` 为后缀。每个测试源码文件都必须至少包含一个测试函数。

## Go 语言对测试函数的名称和签名都有哪些规定？

+ 对于功能测试函数来说，其名称必须以 Test 为前缀，并且参数列表中只应有一个 `*testing.T` 类型的参数声明。
+ 对于性能测试函数来说，其名称必须以 Benchmark 为前缀，并且唯一参数的类型必须是 `*testing.B` 类型的。
+ 对于示例测试函数来说，其名称必须以 Example 为前缀，但对函数的参数列表没有强制规定。

## go test

1. 在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。
2. 针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。

为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试。

由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。更具体地说，只有在所有构建步骤都做完之后，go test 命令才会真正地开始进行性能测试。

## 缓存

由于测试代码与被测代码都没有任何变动，所以 go test 命令直接把之前缓存测试成功的结果打印出来了。

`go clean -cache` 删除所有的缓存数据

`go clean -testcache` 将会删除所有的测试结果缓存。

设置环境变量 GODEBUG 的值也可以稍稍地改变 go 命令的缓存行为。比如，设置值为 `gocacheverify=1` 将会导致 go 命令绕过任何的缓存数据，而真正地执行操作并重新生成所有结果，然后再去检查新的结果与现有的缓存数据是否一致。

对于失败测试的结果，go test 命令并不会进行缓存，所以，这种情况下的每次测试都会产生全新的结果。

## 性能测试

1. go test 命令会先尝试把 b.N 设置为 1，然后执行测试函数。
2. 如果测试函数的执行时间没有超过上限（此上限默认为 1 秒），那么命令就会改大 b.N 的值，然后再次执行测试函数，如此往复，直到这个时间大于或等于上限为止。

`go test -bench=. -run=^\$ puzzlers/article20/q3`

```
goos: darwin
goarch: amd64
pkg: puzzlers/article20/q3
BenchmarkGetPrimes-4 300000 3724 ns/op
PASS
ok puzzlers/article20/q3 1.174s
```

`BenchmarkGetPrimes-8` 被称为单个性能测试的名称，它表示命令执行了性能测试函数 BenchmarkGetPrimes，并且当时所用的最大 P 数量为 8。最大 P 数量相当于可以同时运行 goroutine 的逻辑 CPU 的最大个数。

`3724 ns/op` 表明单次执行 GetPrimes 函数的平均耗时为 2314 纳秒。这其实就是通过将最后一次执行测试函数时的执行时间，除以（被测函数的）执行次数而得出的。

`300000` 我们可以简称该值为执行次数，但要注意，它指的是被测函数的执行次数，而不是性能测试函数的执行次数。

## param

### -cpu（默认只包含一个值，即最大 P 数量的默认值/当前计算机 CPU 核心的实际数量）

go test 命令在进行准备工作的时候会读取 -cpu 标记的值，并把它转换为一个以 int 为元素类型的切片，我们也可以称它为逻辑 CPU 切片。

在准备执行某个测试函数的时候，无论该函数是功能测试函数，还是性能测试函数，go test 命令都会迭代逻辑 CPU 切片，并且在每次迭代时，先依据当前的元素值设置最大 P 数量，然后再去执行测试函数。

go test 命令每一次对性能测试函数的执行，都是一个探索的过程。它会在测试函数的执行时间上限不变的前提下，尝试找到被测程序的最大执行次数。(b.N)

对性能测试函数的一次探索式执行，这其中包含了对该函数的若干次执行，当然，肯定也包括了对被测程序更多次的执行。

### -count（默认值为 1）

-count 标记是专门用于重复执行测试函数的。它的值必须大于或等于 0。

性能测试函数的执行次数 = `-cpu 标记的值中正整数的个数` × `-count 标记的值` × `探索式执行中测试函数的实际执行次数`
功能测试函数的执行次数 = `-cpu 标记的值中正整数的个数` × `-count 标记的值`

有些时候，在输入完全相同的情况下，被测程序会因其他外部环境的不同，而表现出不同的行为。这时我们需要考虑的往往应该是：这个程序在设计上是否合理，而不是通过重复执行测试来检测风险。

还有些时候，我们的程序会无法避免地依赖一些外部环境，比如数据库或者其他服务。这时，我们依然不应该让测试的反复执行成为检测手段，而应该在测试中通过仿造（mock）外部环境，来规避掉它们的不确定性。

单元测试的意思就是：对单一的功能模块进行边界清晰的测试，并且不掺杂任何对外部环境的检测。这也是“单元”二字要表达的主要含义。

通过 -cpu 标记，我们还能够模拟被测程序在计算能力不同计算机中的性能表现。

不过要注意，这里设置的最大 P 数量，最好不要超过当前计算机 CPU 核心的实际数量。因为一旦超出计算机实际的并行处理能力，Go 程序在性能上就无法再得到显著地提升了。

### -parallel

-parallel 标记的作用是：设置同一个被测代码包中的功能测试函数的最大并发执行数。该标记的默认值是测试运行时的最大 P 数量（这可以通过调用表达式 `runtime.GOMAXPROCS(0)` 获得）。

在默认情况下，对于同一个被测代码包中的多个功能测试函数，命令会串行地执行它们。除非我们在一些功能测试函数中显式地调用 t.Parallel 方法。

这个时候，这些包含了 t.Parallel 方法调用的功能测试函数就会被 go test 命令并发地执行，而并发执行的最大数量正是由 -parallel 标记值决定的。不过要注意，同一个功能测试函数的多次执行之间一定是串行的。

-parallel 标记对性能测试是无效的。当然了，对于性能测试来说，也是可以并发进行的，不过机制上会有所不同。


## 性能测试函数中的计时器

StartTimer、StopTimer 和 ResetTimer。这些方法都是用于操作当前的性能测试函数专属的计时器的。这些字段用于记录：当前测试函数在当次执行过程中耗费的时间、分配的堆内存的字节数以及分配次数。

在性能测试函数中，我们可以通过对 b.StartTimer 和 b.StopTimer 方法的联合运用，再去除掉任何一段代码的执行时间。相比之下，b.ResetTimer 方法的灵活性就要差一些了，它只能用于：去除在调用它之前那些代码的执行时间。不过，无论在调用它的时候，计时器是不是正在运行，它都可以起作用。
