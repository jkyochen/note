# bufio

## bufio.Reader 类型值中的缓冲区起着怎样的作用？

bufio.Reader 类型的值（以下简称 Reader 值）内的缓冲区，其实就是一个数据存储中介，它介于底层读取器与读取方法及其调用方之间。所谓的底层读取器，就是在初始化此类值的时候传入的 io.Reader 类型的参数值。

Reader 值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂存于缓冲区之中以备后用。有这样一个缓冲区的好处是，可以在大多数的时候降低读取方法的执行时间。虽然，读取方法有时还要负责填充缓冲区，但从总体来看，读取方法的平均执行时间一般都会因此有大幅度的缩短。

### fill

fill 方法会先检查其所属值的已读计数。如果这个计数不大于 0，那么有两种可能。一种可能是其缓冲区中的字节都是全新的，也就是说它们都没有被读取过，另一种可能是缓冲区刚被压缩过。

fill 方法只要在开始时发现其所属值的已读计数大于 0，就会对缓冲区进行一次压缩。之后，如果缓冲区中还有可写的位置，那么该方法就会对其进行填充。

在填充缓冲区的时候，fill 方法会试图从底层读取器那里，读取足够多的字节，并尽量把从已写计数代表的索引位置到缓冲区末尾之间的空间都填满。

## bufio.Writer 类型值中缓冲的数据什么时候会被写到它的底层写入器？

bufio.Writer 类型有一个名为 Flush 的方法，它的主要功能是把相应缓冲区中暂存的所有数据，都写到底层写入器中。数据一旦被写进底层写入器，该方法就会把它们从缓冲区中删除掉。此外，如果 Write 方法发现需要写入的字节太多，同时缓冲区已空，那么它就会跨过缓冲区，并直接把这些数据写到底层写入器中。

虽然这些写入方法都会不时地调用 Flush 方法，但是在写入所有的数据之后再显式地调用一下这个方法总是最稳妥的。

## bufio.Reader 类型读取方法有哪些不同？

Peek、Read、ReadSlice 和 ReadBytes

Peek 方法的特点是即使读取了缓冲区中的数据，也不会更改已读计数的值。

Read 方法会在参数值的长度过大，且缓冲区中已无未读字节时，跨过缓冲区并直接向底层读取器索要数据。

ReadSlice 方法会在缓冲区的未读部分中寻找给定的分隔符，并在必要时对缓冲区进行填充。如果在填满缓冲区之后仍然未能找到分隔符，那么该方法就会把整个缓冲区作为第一个结果值返回，同时返回缓冲区已满的错误。

ReadBytes 方法会通过调用 ReadSlice 方法，一次又一次地填充缓冲区，并在其中寻找分隔符。除非发生了未预料到的错误或者找到了分隔符，否则这一过程将会一直进行下去。

ReadLine 方法会依赖于它的 ReadSlice 方法，而其 ReadString 方法则完全依赖于 ReadBytes 方法。

bufio.Reader 类型的 Peek 方法、ReadSlice 方法和 ReadLine 方法都有可能会造成内容泄露。
