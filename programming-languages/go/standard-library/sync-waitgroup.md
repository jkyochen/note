# sync.WaitGroup

## WaitGroup

sync 包的 WaitGroup 类型。它比通道更加适合实现这种一对多的 goroutine 协作流程。

sync.WaitGroup 类型（以下简称 WaitGroup 类型）是开箱即用的，也是并发安全的。同时，与我们前面讨论的几个同步工具一样，它一旦被真正使用就不能被复制了。

WaitGroup 类型拥有三个指针方法：Add、Done 和 Wait。你可以想象该类型中有一个计数器，它的默认值是 0。我们可以通过调用该类型值的 Add 方法来增加，或者减少这个计数器的值。

这个类型的 Done 方法，用于对其所属值中计数器的值进行减一操作。

而此类型的 Wait 方法的功能是，阻塞当前的 goroutine，直到其所属值中的计数器归零。如果在该方法被调用的时候，那个计数器的值就是 0，那么它将不会做任何事情。

### sync.WaitGroup 类型值中计数器的值可以小于 0 吗？

不可以。

虽然 WaitGroup 值本身并不需要初始化，但是尽早地增加其计数器的值，还是非常有必要的。

该值中的计数器值由 0 变为了某个正整数，而后又经过一系列的变化，最终由某个正整数又变回了 0。

因此，也可以说，如果一个此类值的 Wait 方法在它的某个计数周期中被调用，那么就会立即阻塞当前的 goroutine，直至这个计数周期完成。在这种情况下，该值的下一个计数周期，必须要等到这个 Wait 方法执行结束之后，才能够开始。

如果在一个此类值的 Wait 方法被执行期间，跨越了两个计数周期，那么就会引发一个 panic。

不要把增加其计数器值的操作和调用其 Wait 方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个 WaitGroup 值的两种操作的并发执行。

### 总结

利用 WaitGroup 值，我们可以很方便地实现一对多的 goroutine 协作流程，即：一个分发子任务的 goroutine，和多个执行子任务的 goroutine，共同来完成一个较大的任务。

我们最好用“先统一 Add，再并发 Done，最后 Wait”这种标准方式，来使用 WaitGroup 值。 尤其不要在调用 Wait 方法的同时，并发地通过调用 Add 方法去增加其计数器的值，因为这也有可能引发 panic。
