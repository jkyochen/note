# container

List 和 Element 都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。

语句 `var l list.List` 声明的链表可以直接使用。

List 这个结构体类型有两个字段，一个是 Element 类型的字段 root，另一个是 int 类型的字段 len。顾名思义，前者代表的就是那个根元素，而后者用于存储链表的长度。注意，它们都是包级私有的，也就是说使用者无法查看和修改它们。

像前面那样声明的 l，其字段 root 和 len 都会被赋予相应的零值。len 的零值是 0，正好可以表明该链表还未包含任何元素。由于 root 是 Element 类型的，所以它的零值就是该类型的空壳，用字面量表示的话就是 Element{}。

Element 类型包含了几个包级私有的字段，分别用于存储前一个元素、后一个元素以及所属链表的指针值。另外还有一个名叫 Value 的公开的字段，该字段的作用就是持有元素的实际值，它是 interface{} 类型的。在 Element 类型的零值中，这些字段的值都会是 nil。

## “延迟初始化”机制

链表的 PushFront 方法、PushBack 方法、 PushBackList 方法以及 PushFrontList 方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。

我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。

## Ring 与 List 的区别

container/ring 包中的 Ring 类型实现的是一个循环链表，也就是我们俗称的环。

List 在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。

List 的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。

## 切片与数组的比较

元素复制一般是免不了的，就算只删除一个元素，有时也会造成大量元素的移动。这时还要注意空出的元素槽位的“清空”，否则很可能会造成内存泄漏。

另一方面，在切片被频繁“扩容”的情况下，新的底层数组会不断产生，这时内存分配的量以及元素复制的次数可能就很可观了，这肯定会对程序的性能产生负面的影响。

尤其是当我们没有一个合理、有效的”缩容“策略的时候，旧的底层数组无法被回收，新的底层数组中也会有大量无用的元素槽位。过度的内存浪费不但会降低程序的性能，还可能会使内存溢出并导致程序崩溃。
