# socket

所谓 socket，是一种 IPC 方法。IPC 是 Inter-Process Communication 的缩写，可以被翻译为进程间通信。顾名思义，IPC 这个概念（或者说规范）主要定义的是多个进程之间，相互通信的方法。

这些方法主要包括：系统信号（signal）、管道（pipe）、套接字 （socket）、文件锁（file lock）、消息队列（message queue）、信号灯（semaphore，有的地方也称之为信号量）等。现存的主流操作系统大都对 IPC 提供了强有力的支持，尤其是 socket。

所谓的系统调用，你可以理解为特殊的 C 语言函数。它们是连接应用程序和操作系统内核的桥梁，也是应用程序使用操作系统功能的唯一渠道。

支持 socket 的操作系统一般都会对外提供一套 API。跑在它们之上的应用程序利用这套 API，就可以与互联网上的另一台计算机中的程序、同一台计算机中的其他程序，甚至同一个程序中的其他线程进行通信。

## net.Dial 函数的第一个参数 network 有哪些可选值？

net.Dial 函数会接受两个参数，分别名为 network 和 address，都是 string 类型的。

参数 network 常用的可选值一共有 9 个。

+ "tcp"：代表 TCP 协议，其基于的 IP 协议的版本根据参数 address 的值自适应。
+ "tcp4"：代表基于 IP 协议第四版的 TCP 协议。
+ "tcp6"：代表基于 IP 协议第六版的 TCP 协议。
+ "udp"：代表 UDP 协议，其基于的 IP 协议的版本根据参数 address 的值自适应。
+ "udp4"：代表基于 IP 协议第四版的 UDP 协议。
+ "udp6"：代表基于 IP 协议第六版的 UDP 协议。
+ "unix"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_STREAM 为 socket 类型。
+ "unixgram"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_DGRAM 为 socket 类型。
+ "unixpacket"：代表 Unix 通信域下的一种内部 socket 协议，以 SOCK_SEQPACKET 为 socket 类型。

## syscall.Socket(domain, typ, proto int) (fd int, err error)

### domain

Socket 的通信域主要有这样几个可选项：IPv4 域、IPv6 域和 Unix 域。

IPv4 域、IPv6 域的含义，它们对应的分别是基于 IP 协议第四版的网络，和基于 IP 协议第六版的网络。

Unix 域，指的是一种类 Unix 操作系统中特有的通信域。在装有此类操作系统的同一台计算机中，应用程序可以基于此域建立 socket 连接。

以上三种通信域分别可以由 syscall 代码包中的常量 AF_INET、AF_INET6 和 AF_UNIX 表示。

Socket 的类型一共有 4 种，分别是：SOCK_DGRAM、SOCK_STREAM、SOCK_SEQPACKET 以及 SOCK_RAW。syscall 代码包中也都有同名的常量与之对应。

### typ

#### SOCK_DGRAM

SOCK_DGRAM 中的“DGRAM”代表的是 datagram，即数据报文。它是一种有消息边界，但没有逻辑连接的非可靠 socket 类型，我们熟知的基于 UDP 协议的网络通信就属于此类。

有消息边界的意思是，与 socket 相关的操作系统内核中的程序（以下简称内核程序）在发送或接收数据的时候是以消息为单位的。

只要应用程序指定好对方的网络地址，内核程序就可以立即把数据报文发送出去。这有优势，也有劣势。

优势是发送速度快，不长期占用网络资源，并且每次发送都可以指定不同的网络地址。

当然了，最后一个优势有时候也是劣势，因为这会使数据报文更长一些。其他的劣势有，无法保证传输的可靠性，不能实现数据的有序性，以及数据只能单向进行传输。

#### SOCK_STREAM

它没有消息边界，但有逻辑连接，能够保证传输的可靠性和数据的有序性，同时还可以实现数据的双向传输。众所周知的基于 TCP 协议的网络通信就属于此类。

这样的网络通信传输数据的形式是字节流，而不是数据报文。字节流是以字节为单位的。内核程序无法感知一段字节流中包含了多少个消息，以及这些消息是否完整，这完全需要应用程序自己去把控。

### proto

syscall.Socket 函数的第三个参数用于表示 socket 实例所使用的协议。

通常，只要明确指定了前两个参数的值，我们就无需再去确定第三个参数值了，一般把它置为 0 就可以了。这时，内核程序会自行选择最合适的协议。

## 问题 1：调用 net.DialTimeout 函数时给定的超时时间意味着什么？

这里的超时时间，代表着函数为网络连接建立完成而等待的最长时间。这是一个相对的时间。它会由这个函数的参数 timeout 的值表示。

开始的时间点几乎是我们调用 net.DialTimeout 函数的那一刻。在这之后，时间会主要花费在“解析参数 network 和 address 的值”，以及“创建 socket 实例并建立网络连接”这两件事情上。

不论执行到哪一步，只要在绝对的超时时间达到的那一刻，网络连接还没有建立完成，该函数就会返回一个代表了 I/O 操作超时的错误值。

值得注意的是，在解析 address 的值的时候，函数会确定网络服务的 IP 地址、端口号等必要信息，并在需要时访问 DNS 服务。

另外，如果解析出的 IP 地址有多个，那么函数会串行或并发地尝试建立连接。但无论用什么样的方式尝试，函数总会以最先建立成功的那个连接为准。同时，它还会根据超时前的剩余时间，去设定针对每次连接尝试的超时时间，以便让它们都有适当的时间执行。

在 net 包中还有一个名为 Dialer 的结构体类型。该类型有一个名叫 Timeout 的字段，它与上述的 timeout 参数的含义是完全一致的。实际上，net.DialTimeout 函数正是利用了这个类型的值才得以实现功能的。
