# strings

## 与 string 值相比， strings.Builder 类型的值有哪些优势？

1. 已存在的内容不可变，但可以拼接更多的内容；
2. 减少了内存分配和内容拷贝的次数；
3. 可将内容重置，可重用值。

### string

在 Go 语言中， string 类型的值是不可变的。

在底层，一个 string 值的内容会被存储到一块连续的内存空间中。同时，这块内存容纳的字节数量也会被记录下来，并用于表示该 string 值的长度。

-   裁剪操作可以使用切片表达式；

    -   你可以把这块内存的内容看成一个字节数组，而相应的 string 值则包含了指向字节数组头部的指针值。如此一来，我们在一个 string 值上应用切片表达式，就相当于在对其底层的字节数组做切片。

-   拼接操作可以用操作符 `+` 实现。

    -   在进行字符串拼接的时候，Go 语言会把所有被拼接的字符串依次拷贝到一个崭新且足够大的连续内存空间中，并把持有相应指针值的 string 值作为结果返回。

注意，虽然 string 值在内部持有一个指针值，但其类型仍然属于值类型。不过，由于 string 值的不可变，其中的指针值也为内存空间的节省做出了贡献。

更具体地说，一个 string 值会在底层与它的所有副本共用同一个字节数组。由于这里的字节数组永远不会被改变，所以这样做是绝对安全的。

### strings.Builder

Builder 值中有一个用于承载内容的容器（以下简称内容容器）。它是一个字节切片。底层数组就是一个字节数组。与 string 值存储内容的方式是一样的。它们都是通过一个 unsafe.Pointer 类型的字段来持有那个指向了底层字节数组的指针值的。

Builder 值只能够被拼接或者完全重置。已存在于 Builder 值中的内容是不可变的。

### 扩容

如有必要，Builder 值会自动地对自身的内容容器进行扩容。这里的自动扩容策略与切片的扩容策略一致。

手动扩容，这通过调用 Builder 值的 Grow 方法，它会生成一个字节切片作为新的内容容器，该切片的容量会是原容器容量的二倍再加上 n。之后，它会把原容器中的所有字节全部拷贝到新容器中。

Grow 方法还可能什么都不做。这种情况的前提条件是：当前的内容容器中的未用容量已经够用了，即：未用容量大于或等于 n。这里的前提条件与前面提到的自动扩容策略中的前提条件是类似的。

Builder 值是可以被重用的。通过调用它的 Reset 方法，我们可以让 Builder 值重新回到零值状态，就像它从未被使用过那样。

一旦被重用，Builder 值中原有的内容容器会被直接丢弃。之后，它和其中的所有内容，将会被 Go 语言的垃圾回收器标记并回收掉。

## 问题 1：strings.Builder 类型在使用上有约束吗？

-   在已被真正使用后就不可再被复制；包括但不限于在函数间传递值、通过通道传递值、把值赋予变量等等。
-   由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题。

正是由于已使用的 Builder 值不能再被复制，所以肯定不会出现多个 Builder 值中的内容容器（也就是那个字节切片）共用一个底层字节数组的情况。这样也就避免了多个同源的 Builder 值在拼接内容时可能产生的冲突问题。

虽然已使用的 Builder 值不能再被复制，但是它的指针值却可以。无论什么时候，我们都可以通过任何方式复制这样的指针值。注意，这样的指针值指向的都会是同一个 Builder 值。

如果 Builder 值被多方同时操作，那么其中的内容就很可能会产生混乱。这就是我们所说的操作冲突和并发安全问题。

最彻底的解决方案是，绝不共享 Builder 值以及它的指针值。

我们可以在各处分别声明一个 Builder 值来使用，也可以先声明一个 Builder 值，然后在真正使用它之前，便将它的副本传到各处。另外，我们还可以先使用再传递，只要在传递之前调用它的 Reset 方法即可。

## 问题 2：为什么说 strings.Reader 类型的值可以高效地读取字符串？

在读取的过程中，Reader 值会保存已读取的字节的计数（以下简称已读计数）。已读计数也代表着下一次读取的起始索引位置。Reader 值正是依靠这样一个计数，以及针对字符串值的切片表达式，从而实现快速读取。

此外，这个已读计数也是读取回退和位置设定时的重要依据。虽然它属于 Reader 值的内部结构，但我们还是可以通过该值的 Len 方法和 Size 把它计算出来的。

Reader 值拥有的大部分用于读取的方法都会及时地更新已读计数。

`ReadByte` 方法会在读取成功后将这个计数的值加 1。

`ReadRune` 方法在读取成功之后，会把被读取的字符所占用的字节数作为计数的增量。

`ReadAt` 它既不会依据已读计数进行读取，也不会在读取后更新它。正因为如此，这个方法可以自由地读取其所属的 Reader 值中的任何内容。

`Seek` 设定下一次读取的起始索引位置。返回新的计数值。

Reader 值实现高效读取的关键就在于它内部的已读计数。计数的值就代表着下一次读取的起始索引位置。
