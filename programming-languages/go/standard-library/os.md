# os

这个代码包提供的都是平台不相关的 API。

## os.File 类型都实现了哪些 io 包中的接口？

os.File 类型拥有的都是指针方法，所以除了空接口之外，它本身没有实现任何接口。而它的指针类型则实现了很多 io 代码包中的接口。

首先，对于 io 包中最核心的 3 个简单接口 io.Reader、io.Writer 和 io.Closer，`*os.File` 类型都实现了它们。

其次，该类型还实现了另外的 3 个简单接口，即：io.ReaderAt、io.Seeker 和 io.WriterAt。


正是因为 `*os.File` 类型实现了这些简单接口，所以它也顺便实现了 io 包的 9 个扩展接口中的 7 个。

然而，由于它并没有实现简单接口 io.ByteReader 和 io.RuneReader，所以它没有实现分别作为这两者的扩展接口的 io.ByteScanner 和 io.RuneScanner。

总之，os.File 类型及其指针类型的值，不但可以通过各种方式读取和写入某个文件中的内容，还可以寻找并设定下一次读取或写入时的起始索引位置，另外还可以随时对文件进行关闭。

但是，它们并不能专门地读取文件中的下一个字节，或者下一个 Unicode 字符，也不能进行任何的读回退操作。

不过，单独读取下一个字节或字符的功能也可以通过其他方式来实现，比如，调用它的 Read 方法并传入适当的参数值就可以做到这一点。

## 问题 1：可应用于 File 值的操作模式都有哪些？

Create、NewFile、Open 和 OpenFile。

`os.Create` 函数，我们可以在操作系统中创建一个全新的文件，或者清空一个现存文件中的全部内容并重用它。

`os.NewFile` 函数并不是被用来创建新文件的，但是它能够基于一个有效的文件描述符包装出一个可用的 File 值。

`os.Open` 函数的功能是打开一个已经存在的文件。但是，我们只能通过它返回的 File 值对相应的文件进行读操作。

`os.OpenFile` 是这些函数中最为灵活的一个，通过它，我们可以设定被打开文件的操作模式和权限模式。实际上，os.Create 函数和 os.Open 函数都只是对它的简单封装而已。

在使用 os.OpenFile 函数的时候，我们必须要搞清楚操作模式和权限模式所代表的真正含义，以及设定它们的正确方式。

## 问题 2：怎样设定常规文件的访问权限？

由于 os.FileMode 是基于 uint32 类型的再定义类型，所以它的每个值都包含了 32 个比特位。在这 32 个比特位当中，每个比特位都有其特定的含义。

比如，如果在其最高比特位上的二进制数是 1，那么该值表示的文件模式就等同于 os.ModeDir ，也就是说，相应的文件代表的是一个目录。


实际上，在一个 os.FileMode 类型的值（以下简称 FileMode 值）中，只有最低的 9 个比特位才用于表示文件的权限。

这个常量的值是 0777，是一个八进制的无符号整数，其最低的 9 个比特位上都是 1，而更高的 23 个比特位上都是 0。

在这 9 个用于表示文件权限的比特位中，每 3 个比特位为一组，共可分为 3 组。

从高到低，这 3 组分别表示的是文件所有者（也就是创建这个文件的那个用户）、文件所有者所属的用户组，以及其他用户对该文件的访问权限。而对于每个组，其中的 3 个比特位从高到低分别表示读权限、写权限和执行权限。
