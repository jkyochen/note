# sync/atomic

互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）。

在众多的同步工具中，真正能够保证原子性执行的只有原子操作（atomic operation）。原子操作在进行的过程中是不允许中断的。在底层，这会由 CPU 提供芯片级别的支持，所以绝对有效。即使在拥有多 CPU 核心，或者多 CPU 的计算机系统中，原子操作的保证也是不可撼动的。

正是因为原子操作不能被中断，所以它需要足够简单，并且要求快速。如果原子操作迟迟不能完成，而它又不会被中断，那么将会给计算机执行指令的效率带来多么大的影响。

Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代码包 sync/atomic 中。

## sync/atomic 包中提供了几种原子操作？可操作的数据类型又有哪些？

1. 加法（add）
2. 比较并交换（compare and swap，简称 CAS）
3. 加载（load）
4. 存储（store）
5. 交换（swap）

这些函数针对的数据类型并不多。但是，对这些类型中的每一个，sync/atomic 包都会有一套函数给予支持。这些数据类型有：int32、int64、uint32、uint64、uintptr，以及 unsafe 包中的 Pointer。不过，针对 unsafe.Pointer 类型，该包并未提供进行原子加法操作的函数。

此外，sync/atomic 包还提供了一个名为 Value 的类型，它可以被用来存储任意类型的值。

## 传入这些原子操作函数的第一个参数的类型为什么不是 int32 而是 `*int32` 呢？

因为原子操作函数需要的是被操作值的指针，而不是这个值本身；被传入函数的参数值都会被复制，像这种基本类型的值一旦被传入函数，就已经与函数外的那个值毫无关系了。

unsafe.Pointer 类型虽然是指针类型，但是那些原子操作函数要操作的是这个指针值，而不是它指向的那个值，所以需要的仍然是指向这个指针值的指针。

只要原子操作函数拿到了被操作值的指针，就可以定位到存储该值的内存地址。只有这样，它们才能够通过底层的指令，准确地操作这个内存地址上的数据。

## 用于原子加法操作的函数可以做原子减法吗？

atomic.AddInt32 函数的第二个参数代表差量，它的类型是 int32，是有符号的。如果我们想做原子减法，那么把这个差量设置为负整数就可以了。

atomic.AddUint32 和 atomic.AddUint64 函数做原子减法，就不能这么直接了，因为它们的第二个参数的类型分别是 uint32 和 uint64，都是无符号的

```golang
// 1
var delta = int32(-3)
uint32(delta)

// 2 补码
^uint32(-N-1)
// N 代表由负整数表示的差量。
```

## 比较并交换操作与交换操作相比有什么不同？优势在哪里？

比较并交换操作即 CAS 操作，是有条件的交换操作，只有在条件满足的情况下才会进行值的交换。

在进行 CAS 操作的时候，函数会先判断被操作变量的当前值，是否与我们预期的旧值相等。如果相等，它就把新值赋给该变量，并返回 true 以表明交换操作已进行；否则就忽略交换操作，并返回 false。

在 for 语句中的 CAS 操作可以不停地检查某个需要满足的条件，一旦条件满足就退出 for 循环。这就相当于，只要条件未被满足，当前的流程就会被一直“阻塞”在这里。

我们在使用互斥锁的时候，总是假设共享资源的状态会被其他的 goroutine 频繁地改变。而 for 语句加 CAS 操作的假设往往是：共享资源状态的改变并不频繁，或者，它的状态总会变成期望的那样。这是一种更加乐观，或者说更加宽松的做法。

## 假设我已经保证了对一个变量的写操作都是原子操作，比如：加或减、存储、交换等等，那我对它进行读操作的时候，还有必要使用原子操作吗？

一旦你决定了要对一个共享资源进行保护，那就要做到完全的保护。

只涉及并发地读写单一的整数类型值，或者多个互不相关的整数类型值，那就不要再考虑互斥锁了。

在使用 CAS 操作的时候，我们还是要多加注意的，因为它可以被用来模仿锁，并有可能“阻塞”流程。

## 怎样用好 sync/atomic.Value？

为了扩大原子操作的适用范围，Go 语言在 1.4 版本发布的时候向 sync/atomic 包中添加了一个新的类型 Value。此类型的值相当于一个容器，可以被用来“原子地”存储和加载任意的值。

Store 和 Load

一旦 atomic.Value 类型的值（以下简称原子值）被真正使用，它就不应该再被复制了。

复制该类型的值会产生一个完全分离的新值。这个新值相当于被复制的那个值的一个快照。之后，不论后者存储的值怎样改变，都不会影响到前者，反之亦然。

### Store

1. 第一条规则，不能用原子值存储 nil，否则就会引发一个 panic。

    这里要注意，如果有一个接口类型的变量，它的动态值是 nil，但动态类型却不是 nil，那么它的值就不等于 nil。

2. 第二条规则，我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。

    因为原子值内部是依据被存储值的实际类型来做判断的。所以，即使是实现了同一个接口的不同类型，它们的值也不能被先后存储到同一个原子值中。

### 使用建议

1. 不要把内部使用的原子值暴露给外界。
2. 如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。若不合法，则应该直接返回对应的错误值，从而避免 panic 的发生。
3. 如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。
4. 尽量不要向原子值中存储引用类型的值。

