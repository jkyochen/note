# sync.Once

## sync.Once 类型值的 Do 方法是怎么保证只执行参数函数一次的？

与 sync.WaitGroup 类型一样，sync.Once 类型（以下简称 Once 类型）也属于结构体类型，同样也是开箱即用和并发安全的。由于这个类型中包含了一个 sync.Mutex 类型的字段，所以，复制该类型的值也会导致功能的失效。

Once 类型的 Do 方法只接受一个参数，这个参数的类型必须是 func()，即：无参数声明和结果声明的函数。

该方法的功能并不是对每一种参数函数都只执行一次，而是只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数。

所以，如果你有多个只需要执行一次的函数，那么就应该为它们中的每一个都分配一个 sync.Once 类型的值（以下简称 Once 值）。

Once 类型中还有一个名叫 done 的 uint32 类型的字段。它的作用是记录其所属值的 Do 方法被调用的次数。不过，该字段的值只可能是 0 或者 1。一旦 Do 方法的首次调用完成，它的值就会从 0 变为 1。

## 为什么还要使用需要四个字节的 uint32 类型呢？

原因很简单，因为对它的操作必须是“原子”的。Do 方法在一开始就会通过调用 atomic.LoadUint32 函数来获取该字段的值，并且一旦发现该值为 1，就会直接返回。这也初步保证了“Do 方法，只会执行首次被调用时传入的函数”。

不过，单凭这样一个判断的保证是不够的。因为，如果有两个 goroutine 都调用了同一个新的 Once 值的 Do 方法，并且几乎同时执行到了其中的这个条件判断代码，那么它们就都会因判断结果为 false，而继续执行 Do 方法中剩余的代码。

在这个条件判断之后，Do 方法会立即锁定其所属值中的那个 sync.Mutex 类型的字段 m。然后，它会在临界区中再次检查 done 字段的值，并且仅在条件满足时，才会去调用参数函数，以及用原子操作把 done 的值变为 1。

如果你熟悉 GoF 设计模式中的单例模式的话，那么肯定能看出来，这个 Do 方法的实现方式，与那个单例模式有很多相似之处。它们都会先在临界区之外，判断一次关键条件，若条件不满足则立即返回。这通常被称为 **“快路径”，或者叫做“快速失败路径”。**

如果条件满足，那么到了临界区中还要再对关键条件进行一次判断，这主要是为了更加严谨。这两次条件判断常被统称为（跨临界区的）“双重检查”。

## 特点

1. 第一个特点，由于 Do 方法只会在参数函数执行结束之后把 done 字段的值变为 1，因此，如果参数函数的执行需要很长时间或者根本就不会结束（比如执行一些守护任务），那么就有可能会导致相关 goroutine 的同时阻塞。

2. 第二个特点，Do 方法在参数函数执行结束后，对 done 字段的赋值用的是原子操作，并且，这一操作是被挂在 defer 语句中的。因此，不论参数函数的执行会以怎样的方式结束，done 字段的值都会变为 1。

也就是说，即使这个参数函数没有执行成功（比如引发了一个 panic），我们也无法使用同一个 Once 值重新执行它了。

## 总结

Once 值的使用方式比 WaitGroup 值更加简单，它只有一个 Do 方法。同一个 Once 值的 Do 方法，永远只会执行第一次被调用时传入的参数函数，不论这个函数的执行会以怎样的方式结束。只要传入某个 Do 方法的参数函数没有结束执行，任何之后调用该方法的 goroutine 就都会被阻塞。只有在这个参数函数执行结束以后，那些 goroutine 才会逐一被唤醒。

once 一般是执行只应该执行一次的任务，比如初始化连接池等等。
