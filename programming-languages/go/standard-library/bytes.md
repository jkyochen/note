# bytes

strings 包主要面向的是 Unicode 字符和经过 UTF-8 编码的字符串，而 bytes 包面对的则主要是字节和字节切片。

strings.Builder 只能拼接和导出字符串，而 bytes.Buffer 不但可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。

在内部，bytes.Buffer 类型同样是使用字节切片作为内容容器的。并且，与 strings.Reader 类型类似，bytes.Buffer 有一个 int 类型的字段，用于代表已读字节的计数，可以简称为已读计数。

不过，这里的已读计数就无法通过 bytes.Buffer 提供的方法计算出来了。

Buffer 值的长度是未读内容的长度，而不是已存内容的总长度。

## bytes.Buffer 类型的值记录的已读计数，在其中起到了怎样的作用？

-   读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数。
-   写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略。
-   截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分。
-   读回退时，相应方法需要用已读计数记录回退点。
-   重置内容时，相应方法会把已读计数置为 0。
-   导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分。
-   获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回。


## 问题 1：bytes.Buffer 的扩容策略是怎样的？

1. 如果内容容器的容量与其长度的差，大于或等于另需的字节数，那么扩容代码就会通过切片操作对原有的内容容器的长度进行扩充。

    `b.buf = b.buf[:length+need]`

2. 如果当前内容容器的容量的一半，仍然大于或等于其现有长度再加上另需的字节数的和，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。

    `cap(b.buf)/2 >= len(b.buf)+need`

3. 否则新容器的容量 = `2 * 原有容量 + 所需字节数`

对于处在零值状态的 Buffer 值来说，如果第一次扩容时的另需字节数不大于 64，那么该值就会基于一个预先定义好的、长度为 64 的字节数组来创建内容容器。


## 问题 2：bytes.Buffer 中的哪些方法可能会造成内容的泄露？

在 bytes.Buffer 中， Bytes 方法和 Next 方法都可能会造成内容的泄露。原因在于，它们都把基于内容容器的切片直接返回给了方法的调用方。

在这个 Buffer 值中放入了一个长度为 2 的字符串值，但为什么该值的容量却变为了 8。可以去阅读 runtime 包中一个名叫 stringtoslicebyte 的函数，答案就在其中。
